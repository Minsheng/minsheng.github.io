<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Real Time Mixed Reality</title>
        <style>
            body {
            	font-family: Monospace;
            	background-color: #f0f0f0;
            	margin: 0px;
            	overflow: hidden;
            }
        </style>
    </head>
    <body onload="justRunFam()">
        <div id="canvas"></div>
		<script type="text/javascript" src="js/jquery-3.1.0.min.js"></script>
        <script type="text/javascript" src="js/three-r70.min.js"></script>
        <script type="text/javascript" src="js/TrackballControls.js"></script>
        <script type="text/javascript" src="js/Detector.js"></script>
        <script type="text/javascript" src="js/shader.js"></script>
        <script type="text/javascript" src="js/math.js"></script>
        <script type="text/javascript" src="js/pubnub.4.0.6.min.js"></script>

        <script type="text/javascript">
            /*
            *** References ***
            Pubnub code sample from,
            https://www.pubnub.com/docs/javascript/api-reference-sdk-v4

            City model generation code modified from
            THREE.geojson by Sebastian Meier,
            https://github.com/sebastian-meier/THREE.geojson

            Trackball control code sample from,
            https://github.com/mrdoob/three.js/blob/dev/examples/misc_controls_trackball.html

            All other code are co-created by
            Michael James Carnevale
            Minsheng (Davidson) Zheng

            August, 2016
            */

            // User data structure
            class User {
                constructor(uuid, geoloc) {
                    this.uuid = uuid;
                    this.geoloc = geoloc;
                }
            }

            // pubub channel
            const MR_CHANNEL = 'mr-demo';

            // the interval to request geolocation data
            const GEO_INTERVAL = 2 * 1000; // seconds * milliseconds

            // geolocation config options
            const GEO_OPT = {
                timeout: (2 * 1000),
                maximumAge: 0,
                enableHighAccuracy: true
            };

            // Set as True if you want to see Data Calculation Logs
            const IS_LOG_DATA_ON = false;

            // For console log messages
			const IS_LOG_ON = false;

            // determines the duration a user can stay in the channel
            const USER_TIMEOUT = 120;

            const USER_OBJ_RADIUS = 4; // determines the size of a user object
            const USER_OBJ_HEIGHT = 100; // initial postion in vertical axis

            const FPS = 30; // frame rate per second when animated

            /* Modes for generating object positions.
            Because the changes in geo coordinates are too tiny for each user,
            we need to translate the value based on the mean of the coordinates
            of the map elements and scale them by taking the nth and (n+1)th
            digits after decimal point in order to have significant changes
            in scene positions
             */
            const TRANSLATE_MODE = 1;
            const RAW_MODE = 2;
            const SCALED_MODE = 3;

            var users = {};
            var currUuid = '';

            // configs for bulding 3D city model
            /*
				Dataset specific:
					if useHeight = true then the height is calculated from the heightAttr value in the geoJson file
					if not the height of each object will be 0
			*/
            const DOWNTOWN_MDL_PATH = "./models/dt.geojson";
            const OCADU_MDL_PATH = "./models/richmond.geojson";
            const WATERFRONT_MDL_PATH = "./models/waterfront_1.geojson";
            const MIDTOWN = "./models/Midtown_5.geojson";

            var jsonFile = WATERFRONT_MDL_PATH, // default
				useHeight = true,
				heightAttr = "EleZ",
				heightFn = function(val) {
                    return Math.pow(parseFloat(val), root);
                },
				root = 1/2.5,
				max = heightFn(900),
				z_max = 500.0,
				z_rel = 0.01,
				offset_x = -45,
				offset_y = 59,
				offset_z = 0,
				r = 0,
				scale_x = 209,
				scale_y = 350,
				scale_factor = 0.1,
				heightScaler = 0.5,
				animateHeight = false;

            var LAT_MEAN = 0;
            var LNG_MEAN = 0;

            // Due to javascripts limitations
            // we need to parse the data in subsets (5000)
            var shapeCount = 0,
                shapes = [],
                subset_size = 5000;

            // for Threejs
            var scene, camera, renderer, controls, container, light;
            var json, mesh, group, groupGeometry;

            // All zero or false height values will be ignored
            var fast = false;
            var ww = window.innerWidth;
            var wh = window.innerHeight;

            function justRunFam() {
                if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

                currUuid = generateUUID(); // generate a random id for the current user

                //////////////////////////
                // Pubnub data transmission setup
                //////////////////////////

                var pubnub = new PubNub({
                    publishKey: 'pub-c-d223f6bb-65ab-4128-b272-3984970759c1',
                    subscribeKey: 'sub-c-441be6a2-5d04-11e6-ada4-02ee2ddab7fe',
                    ssl: true,
                    uuid: currUuid,
                    heartbeatInterval: 5,
                    presenceTimeout: USER_TIMEOUT
                });

                pubnub.subscribe({
                    channels: [MR_CHANNEL],
                    withPresence: true
                });

                // View the UUID and state objects of those currently subscribed
                pubnub.hereNow(
                    {
                        channels: [MR_CHANNEL],
                        includeUUIDs: true
                    },
                    function (status, response) {
                        // handle status, response
                        log(response);

                        if (response.channels[MR_CHANNEL]) {
                            var userList = response['channels'][MR_CHANNEL]['occupants'];
                            initializeUsers(userList);

                            log("Loading of map model starts");

                            buildModelAndScene();

                            pubnub.addListener({
                                status: function(statusEvent) {
                                    if (statusEvent.category === "PNConnectedCategory") {
                                    }
                                },
                                message: function(m) {
                                    var data = m.message;

                                    if (!jQuery.isEmptyObject(data) &&
                                        data.uuid &&
                                        !jQuery.isEmptyObject(data.geoloc)) {

                                        // update geolocation only for other users
                                        if (data.uuid !== currUuid) {
                                            updatePosition(data);
                                            // animate();
                                        }
                                    }
                                },
                                presence: function(e) {
                                    updateUsers(e);
                                    // animate();
                                }
                            });
                        }
                    }
                );

                //////////////////////////
                // Get geolocation
                //////////////////////////
                setInterval(function(){
                    refreshGeolocation();
                }, GEO_INTERVAL);

                function initScene() {
                    container = $('#canvas');

                    //////////////////////////
                    // Camera setup
                    //////////////////////////
                    camera = new THREE.PerspectiveCamera( 45, ww / wh, 0.1, 10000 );
                    // place camera up and looking down
                    camera.position.set(0,100,400);
                    // camera.up = new THREE.Vector3(0,0,0);
                    // camera.lookAt(new THREE.Vector3(0,0,0));

                    // city model bird's eye camera visew
                    // camera = new THREE.PerspectiveCamera(600, (width / height), 1, 20000);
                    // camera.position.set(0, 0, 500);
                    // camera.up = new THREE.Vector3(0,0,-1);
                    // camera.translateZ( 100 );

                    scene = new THREE.Scene();
                    scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

                    //////////////////////////
                    // Renderer setup
                    //////////////////////////
                    renderer = new THREE.WebGLRenderer({
                        antialias: false,
                        preserveDrawingBuffer: true,
                        alpha: true
                    });
                    renderer.setSize( ww, wh );
                    // renderer.setSize( ww/2, wh/2, false ); // render at a lower resolution
                    // renderer.setClearColor( 0xffffff );
                    // renderer.setPixelRatio( window.devicePixelRatio );
                    renderer.shadowMapEnabled = true;
                    renderer.shadowMapType = THREE.PCFSoftShadowMap;
                    renderer.setViewport(0, 0, ww, wh);

                    //////////////////////////
                    // Lights
                    //////////////////////////

                    light = new THREE.DirectionalLight( 0xffffff );
                    light.position.set( 1, 1, 1 );
                    scene.add( light );

                    light = new THREE.DirectionalLight( 0x002288 );
                    light.position.set( -1, -1, -1 );
                    scene.add( light );

                    light = new THREE.AmbientLight( 0x222222 );
                    scene.add( light );

                    //////////////////////////
                    // Camera control
                    //////////////////////////
                    controls = new THREE.TrackballControls( camera );
                    controls.rotateSpeed = 1.0;
                    controls.zoomSpeed = 1.2;
                    controls.panSpeed = 0.8;
                    controls.staticMoving = true;
                    controls.dynamicDampingFactor = 0.3;
                    controls.keys = [ 65, 83, 68 ];
                    controls.addEventListener( 'change', render );

                    //////////////////////////
                    // 3D environment
                    //////////////////////////

                    // This group will hold our city objects for easier handling
                    group = new THREE.Object3D();
                    group.position.y = 50;
                    group.position.z = 0;
                    scene.add(group);

                    // This group will hold all geometries
                    groupGeometry = new THREE.Geometry();
                    log("initiation done");
                    buildShape(); //Convert geojson geometries into 3D shapes

                    //////////////////////////
                    // User objects
                    //////////////////////////

                    // add a reference object
                    // var ref = new THREE.BoxGeometry(4, 4, 4);
                    // var refMat = new THREE.MeshLambertMaterial({color: 0xff0000});
                    // var refMesh = new THREE.Mesh(ref, refMat);
                    // refMesh.name = "reference";
                    // refMesh.position.set(35,0,0);
                    // scene.add(refMesh);

                    // add grid helper
                    // var gridHelper = new THREE.GridHelper( 100, 2 );
                    // scene.add( gridHelper );

                    // construct scene and player objects
                    spawnCurrUsers();

                    container.append( renderer.domElement );

                    animate();
                }

                // Modified library code
                //Main Shape-Building Function
                function buildShape() {
                    //Push all Lat/Lng coordinates into two arrays
                    var features = json.features;
                    // log(features);
                    var master = [];

                    features.forEach(function (ele) {
                        if (ele.geometry) {
                            if(ele.geometry.type === "Polygon"){
                            var coord = ele.geometry.coordinates[0]; // [[x1,y1],[x2,y2]]
                            master = master.concat(coord);
                            log("Polygon "+master.length);
                        } else if (ele.geometry.type === "MultiPolygon") {
                            var coord = ele.geometry.coordinates[0][0]; // [[[x1,y1],[x2,y2]]]
                            master = master.concat(coord);
                            log("MultiPolygon"+master.length);
                        }
                    }
                    });

                    var lngAll = master.map(function (d) {
                        return d[0];
                    });

                    var latAll = master.map(function (d) {
                        return d[1];
                    });

                    // Calculate the mean values
                    LNG_MEAN = math.mean(lngAll);
                    LAT_MEAN = math.mean(latAll);

                    //Check and Get coordinates from GEOJSON
                    log("buildShape (" + shapeCount + "/" + json.features.length + ")");
                    if (shapeCount < json.features.length) {
                        var shapeSession = 0;
                        for (var s = shapeCount; s < json.features.length && shapeSession < subset_size; s++) {
                            shapeSession++;
                            shapeCount++;
                            var good = true;
                            var points = [];

                            var geometry = json.features[s].geometry;

                            if (geometry !== null) {
                                var coordinates = [];

                                if (geometry.type === "Polygon") {
                                    coordinates = geometry.coordinates[0];
                                } else if (geometry.type === "MultiPolygon") {
                                    coordinates = geometry.coordinates[0][0];
                                }

                                if (coordinates.length > 0) { // it has to be one nested element
                                    for (var i = 0; i < coordinates.length; i++) {
                                        // Push geometry if all coordinate values are positive
                                        if (coordinates[i][0] && coordinates[i][1]) {
                                            points.push(new THREE.Vector2(
                                                translateLng(coordinates[i][0], LNG_MEAN),
                                                translateLat(coordinates[i][1], LAT_MEAN)
                                            ));
                                            if (IS_LOG_DATA_ON) {
                                                logData(s, i, LNG_MEAN, LAT_MEAN);
                                            }
                                        } else {
                                            good = false;
                                        }
                                    }
                                } else {
                                    good = false;
                                }
                            } else {
                                good = false;
                            }

                            //If the geometry is safe, continue
                            if (good) {

                                //Calculate the height of the current geometry for extrusion
                                var h = heightFn(json.features[s].properties[heightAttr]);
                                if (isNaN(parseFloat(json.features[s].properties[heightAttr]))) {
                                    if (fast) {
                                        good = false;
                                    }
                                    h = 0;
                                }

                                if (!h ||  h < 0) {
                                    if (fast) {
                                        good = false;
                                    }
                                    h = 0;
                                }

                                if (h > max) {
                                    h = max;
                                }

                                //Remove all objects that have no height information for faster rendering
                                if (h == 0 && fast) {
                                    good = false;
                                }
                            }

                            //If the geometry is still safe, continue
                            if (good) {

                                //Calculate the third dimension
                                var z = ((h / max) * z_max);
                                if (!z ||  z < 1) {
                                    z = 0;
                                }

                                //Calculate the color of the object
                                //In this sample code we use a blue to red range to visualize the height of the object (blue short to red tall)
                                // var red = Math.round((h / max) * 255.0);
                                var blue = Math.round(255.0 - (h / max) * 255.0);
                                // var green = 128;
                                var color = new THREE.Color("rgb(" + blue + "," + blue + "," + blue + ")");

                                addShape(new THREE.Shape(points), z * z_rel, color, 0, 50, 0, r, 0, 0, 1);
                            }
                        }

                        //If we have more geometries to add restart the whole loop
                        setTimeout(function () {
                            buildShape();
                        }, 100);
                    } else {

                        //We are done building our geometry
                        log("Geometry Done");

                        //Initiate the shader

                        var shaderMaterial = new THREE.ShaderMaterial({
                            attributes: {},
                            uniforms: {},
                            vertexShader: THREETUT.Shaders.Lit.vertex,
                            fragmentShader: THREETUT.Shaders.Lit.fragment,
                            side: THREE.FrontSide
                        });


                        //Initiate Material

                        var materials = [
                			new THREE.MeshLambertMaterial({
                                vertexColors: THREE.VertexColors,
                //                color: "rgb(0.2,0.2,0.2)",
                //                ambient: "rgb(0.2,0.2,0.2)",
                                color: "rgb(10.9,10.9,10.9)",
                                ambient: "rgb(10.9,10.9,10.9)",
                                shininess: 1,
                                lights: true
                            }),
                			new THREE.MeshLambertMaterial({
                                vertexColors: THREE.VertexColors,
                                color: "rgb(0.5,0.5,0.5)",
                                ambient: "rgb(0.5,0.5,0.5)",
                                shininess: 1,
                                lights: true
                            })
                		];

                        var material = new THREE.MeshFaceMaterial(materials);


                        //Create a mesh from the geometry

                        mesh = new THREE.Mesh(groupGeometry, material);

                        //mesh.position.set(offset_x * 3, offset_y * 3, offset_z * 3);
                        mesh.rotation.set(r, 0, 0);
                        mesh.scale.set(scale_factor * scale_x, scale_factor * scale_y, 0);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;

                        scene.add(mesh);


                        //Too make it a little more fancy, add a directional light

                        // var directionalLight = new THREE.DirectionalLight(0xeeeeee, 1);
                        // directionalLight.position.set(0, 400, 200);
                        // directionalLight.target = mesh;
                        // directionalLight.castShadow = true;
                        // directionalLight.shadowDarkness = 0.5;
                        // scene.add(directionalLight);


                        //Now add the renderer to the DOM
                        // document.body.appendChild(renderer.domElement);


                        //And start animating it
                        log("animate");

                        // animate();

                        //Recalculate if window is resized
                        // window.addEventListener( 'resize', onWindowResize, false );
                    }
                }

                // Adding geometries to group
                function addShape(shape, extrude, color, x, y, z, rx, ry, rz, s) {

                    //Extrusion settings
                    var extrudeSettings = {
                        amount: extrude * 50,
                        steps: 1,
                        material: 0,
                        extrudeMaterial: 1,
                        bevelEnabled: false
                    };

                    //Create the geometry
                    var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

                    //Set the color for the object
                    for (var f = 0; f < geometry.faces.length; f++) {
                        geometry.faces[f].color.setRGB(color.r, color.g, color.b);
                    }

                    //Have a big amount of geometries will slow down THREE.js
                    //Instead we merge all geometries into one geometry
                    groupGeometry.merge(geometry, geometry.matrix);

                }

                function animate() {
                    //Animate at 30fs framerate
                    setTimeout(function () {
                        requestAnimationFrame(animate);
                    }, 1000 / FPS);

                    //Animate the height of the objections
                    if (animateHeight) {
                        heightScaler += 0.001;
                    }

                    if (mesh) {
                        mesh.scale.set(scale_factor * scale_x, scale_factor * scale_y, heightScaler);
                    }

                    render();
                    if (controls) controls.update();
                }

                function render() {
                    if (renderer) renderer.render( scene, camera );
                }

                // Spawn users into the scene
                function spawnCurrUsers() {
                    for (var key in users) {
                        if (users.hasOwnProperty(key)) {
                            var userObj = users[key];

                            if (!jQuery.isEmptyObject(userObj)) {
                                if (userObj.uuid) {
                                    if (!jQuery.isEmptyObject(userObj.geoloc)) {
                                        spawnNewUser(userObj.uuid, userObj.geoloc);
                                    } else {
                                        spawnNewUser(userObj.uuid, {});
                                    }
                                }
                            }
                        }
                    }
                }

                // Takes a user id and create a new 3D object
                function spawnNewUser(uuid, geoloc) {
                    if (uuid) {
                        var sampleGeo = new THREE.SphereGeometry( USER_OBJ_RADIUS, 8, 6 );
                        var sampleMat = new THREE.MeshBasicMaterial( { color: Math.random()*0xffffff} );
                        var sampleMesh = new THREE.Mesh( sampleGeo, sampleMat );

                        sampleMesh.name = uuid;

                        // only set the x,y position if previous position exists
                        if (!jQuery.isEmptyObject(geoloc)) {
                            var x = userObj.geoloc.lat;
                            var y = userObj.geoloc.lng;
                            sampleMesh.position.set(x,y,USER_OBJ_HEIGHT);
                        } else {
                            sampleMesh.position.set(0,0,USER_OBJ_HEIGHT);
                        }

                        if (sampleMesh) {
                            scene.add( sampleMesh );
                        }
                    }
                }

                function refreshGeolocation() {
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(success, function() {
                            handleLocationError(true);
                        }, GEO_OPT);
                    } else {
                        // Browser doesn't support Geolocation
                        handleLocationError(false);
                    }
                }

                /*
                    After successfully retrieving a coordinate,
                    update the position of the current user in the current browser
                    as well as in other users' browsers by publishing the geolocation data
                */
                function success(position) {
                    log("Getting geo location: ");
                    log("Current coordinate before translation: " + position.coords.longitude + "," + position.coords.latitude);

                    mode = SCALED_MODE;

                    var lat = position.coords.latitude;
                    var lng = position.coords.longitude;

                    var translatedLng = translateLng(lng, LNG_MEAN);
                    var translatedLat = translateLat(lat, LAT_MEAN);

                    var pos = {};

                    if (mode === RAW_MODE) {
                        pos.lat = lat;
                        pos.lng = lng;
                    } else if (mode === TRANSLATE_MODE) {
                        pos.lat = translatedLat;
                        pos.lng = translatedLng;
                    } else if (mode === SCALED_MODE) {
                        pos.lat = convertCoord(translatedLat, 2, 3);
                        pos.lng = convertCoord(translatedLng, 2, 3);
                    }

                    // update the geolocation of the current user
                    updatePosition({
                        uuid: currUuid,
                        geoloc: pos
                    });

                    // publish the geolocation of the current user for other clients
                    publishPosition({
                        uuid: currUuid,
                        geoloc: pos
                    });

                    animate();
                    // console.log("Your current loc: " + pos.lat + " , " + pos.lng);
                }

                function handleLocationError(browserHasGeolocation) {
                    log(browserHasGeolocation ?
                        'Error: The Geolocation service failed.' :
                        'Error: Your browser doesn\'t support geolocation.'
                    );
                }

                /*
                    Update the position of a user object
                */
                function updatePosition(data) {
                    if (users.hasOwnProperty(data.uuid)) {
                        var userObj = users[data.uuid];
                        userObj.geoloc = data.geoloc;

                        var x = userObj.geoloc.lat;
                        var y = userObj.geoloc.lng;

                        // update 3D object position
                        var target3DObj = scene.getObjectByName(userObj.uuid);

                        if (target3DObj) {
                            target3DObj.position.set(x, y, USER_OBJ_HEIGHT);
                            // animate();
                        }
                    }
                }

                // broadcast geolocation data in a public channel
                function publishPosition(data) {
                    pubnub.publish({
                        channel: MR_CHANNEL,
                        message: data
                    });
                }

                // initializes user objects
                function initializeUsers(list) {
                    if (list.length > 0) {
                        for (var i=0; i < list.length; i++) {
                            users[list[i]['uuid']] = new User(list[i]['uuid'], {});
                        }
                    } else {
                        log("No users is connected...")
                    }
                }

                /*
                    When a new user joins, create a new user object with the
                    uuid and add it to the master list; spawn the user in the
                    scene.

                    When a user timesout, remove the user from the master list;
                    remove the user from the scene.
                */
                function updateUsers(presence) {
                    if (presence) {
                        var newUuid = presence.uuid;
                        // if another user joins
                        if ((presence.action === "join")) {
                            // update gloal user list
                            users[newUuid] = new User(newUuid, {});

                            spawnNewUser(newUuid, {});
                        }
                        // if a user leaves
                        else if (presence.action === "timeout") {
                            delete users[newUuid]
                            // remove scene object
                            scene.remove(scene.getObjectByName(newUuid));
                        }
                    }
                }

                function buildModelAndScene() {
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(loadCityModel, function() {
                            handleLocationError(true);
                        }, GEO_OPT);
                    } else {
                        // Browser doesn't support Geolocation
                        handleLocationError(false);
                    }
                }

                // Use current user geo-coordinates to choose map model.
                // If user is not within the geo-coordinate bounds of any map model, then use Waterfront_1.geojson as default
                function loadCityModel(position) {
                    var latitude = position.coords.latitude;
                    var longitude = position.coords.longitude;

                    // Waterfront

                    if (longitude > -79.4001682091352 && longitude < -79.3766788232645 && latitude < 43.6473318013964 && latitude > 43.6327892037729) {
                        jsonFile = "./models/Waterfront_1.geojson";
                    }

                    if (longitude > -79.3766788232645 && longitude < -79.3531894373938 && latitude < 43.6473318013964 && latitude > 43.6327892037729) {
                        jsonFile = "./models/Waterfront_2.geojson";
                    }

                    if (longitude > -79.3531894373938 && longitude < -79.3297000515231 && latitude < 43.6473318013964 && latitude > 43.6327892037729) {
                        jsonFile = "./models/Waterfront_3.geojson";
                    }

                    if (longitude > -79.3297000515231 && longitude < -79.3062106656524 && latitude < 43.6473318013964 && latitude > 43.6327892037729) {
                        jsonFile = "./models/Waterfront_4.geojson";
                    }

                    if (longitude > -79.3062106656524 && longitude < -79.2827212797817 && latitude < 43.6473318013964 && latitude > 43.6327892037729) {
                        jsonFile = "./models/Waterfront_5.geojson";
                    }


                    // South Downtown

                    if (longitude > -79.4001682091352 && longitude < -79.3766788232645 && latitude < 43.6618743990199 && latitude > 43.6473318013964) {
                        jsonFile = "./models/South_Downtown_1.geojson";
                    }

                    if (longitude > -79.3766788232645 && longitude < -79.3531894373938 && latitude < 43.6618743990199 && latitude > 43.6473318013964) {
                        jsonFile = "./models/South_Downtown_2.geojson";
                    }

                    if (longitude > -79.3531894373938 && longitude < -79.3297000515231 && latitude < 43.6618743990199 && latitude > 43.6473318013964) {
                        jsonFile = "./models/South_Downtown_3.geojson";
                    }

                    if (longitude > -79.3297000515231 && longitude < -79.3062106656524 && latitude < 43.6618743990199 && latitude > 43.6473318013964) {
                        jsonFile = "./models/South_Downtown_4.geojson";
                    }

                    if (longitude > -79.3062106656524 && longitude < -79.2827212797817 && latitude < 43.6618743990199 && latitude > 43.6473318013964) {
                        jsonFile = "./models/South_Downtown_5.geojson";
                    }


                    // North Downtown

                    if (longitude > -79.4001682091352 && longitude < -79.3766788232645 && latitude < 43.6764169966434 && latitude > 43.6618743990199) {
                        jsonFile = "./models/North_Downtown_1.geojson";
                    }

                    if (longitude > -79.3766788232645 && longitude < -79.3531894373938 && latitude < 43.6764169966434 && latitude > 43.6618743990199) {
                        jsonFile = "./models/North_Downtown_2.geojson";
                    }

                    if (longitude > -79.3531894373938 && longitude < -79.3297000515231 && latitude < 43.6764169966434 && latitude > 43.6618743990199) {
                        jsonFile = "./models/North_Downtown_3.geojson";
                    }

                    if (longitude > -79.3297000515231 && longitude < -79.3062106656524 && latitude < 43.6764169966434 && latitude > 43.6618743990199) {
                        jsonFile = "./models/North_Downtown_4.geojson";
                    }

                    if (longitude > -79.3062106656524 && longitude < -79.2827212797817 && latitude < 43.6764169966434 && latitude > 43.6618743990199) {
                        jsonFile = "./models/North_Downtown_5.geojson";
                    }


                    // MidTown

                    if (longitude > -79.4001682091352 && longitude < -79.3766788232645 && latitude < 43.6909595942669 && latitude > 43.6764169966434) {
                        jsonFile = "./models/Midtown_1.geojson";
                    }

                    if (longitude > -79.3766788232645 && longitude < -79.3531894373938 && latitude < 43.6909595942669 && latitude > 43.6764169966434) {
                        jsonFile = "./models/Midtown_2.geojson";
                    }

                    if (longitude > -79.3531894373938 && longitude < -79.3297000515231 && latitude < 43.6909595942669 && latitude > 43.6764169966434) {
                        jsonFile = "./models/Midtown_3.geojson";
                    }

                    if (longitude > -79.3297000515231 && longitude < -79.3062106656524 && latitude < 43.6909595942669 && latitude > 43.6764169966434) {
                        jsonFile = "./models/Midtown_4.geojson";
                    }

                    if (longitude > -79.3062106656524 && longitude < -79.2827212797817 && latitude < 43.6909595942669 && latitude > 43.6764169966434) {
                        jsonFile = "./models/Midtown_5.geojson";
                    }

                    // initialize 3D environment and objects
                    $.getJSON(jsonFile, function(data) {
                        log("Loading of map model completed");
                        json = data;

                        initScene();
                    });
                }

                //////////////////////////
                // Utilities
                //////////////////////////
                /*
                Create a unique user id,
                Copy from https://www.pubnub.com/docs/javascript/api-reference-sdk-v4#uuid
                */
                function generateUUID() {
                    var d = new Date().getTime();
                    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                        var r = (d + Math.random()*16)%16 | 0;
                        d = Math.floor(d/16);
                        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
                    });
                    return uuid;
                }

                /*
                    Convert a geo coordinate to a number that can be used by
                    the threejs coordinate system
                    dig1 and dig2 are the nth and (n+1)th digits after decimal point.
                    when a user is walking, there are significant changes in
                    these two digits which can be used to set the position of
                    the user object in our virtual scene
                */
                function convertCoord(val, dig1, dig2) {
                    var result = 0;
                    var strDeci = String(val % 1);

                    if (val >=0) {
                        var tenth = strDeci.charAt(dig1);
                        var single = strDeci.charAt(dig2);
                        var res = tenth + single;
                        result = Number(res);
                    } else {
                        var tenth = strDeci.charAt(dig1+1);
                        var single = strDeci.charAt(dig2+1);
                        var res = tenth + single;
                        result = Number(res);
                    }

                    return result;
                }

                // Modify JSON Coordinate Values

                // Calculate a translated latitude based on the mean value of
                // all the latitude values from the map geojson file
                function translateLat(lat, latMean) {
                    if (!lat) lat = 0;
                    if (latMean) lat = (lat - latMean)*1000;
                    return lat;
                }

                // Calculate a translated longitude based on the mean value of
                // all the longitude values from the map geojson file
                function translateLng(lng, lngMean) {
                	if (!lng) lng = 0;
                    if (lngMean) lng = ((lng) - lngMean)*1000;
                    return lng;
                }

                function map_range(value, low1, high1, low2, high2) {
                    return (value - low1) / (high1 - low1) * (high2 - low2) + low2;
                }

                //// Log Functions ////
                function log(m) {
                    if (IS_LOG_ON) console.log(m);
                }

                function logData(featureCount, LatLngCount, lngMean, latMean) {
                    // Log featureCountGEOJSON + CoordinateArray.length + latitude, longitude, & converted values
                    log(featureCount+" "+json.features[featureCount].geometry.coordinates.length+" lng(" + json.features[featureCount].geometry.coordinates[0][LatLngCount][0] + ") lat(" + json.features[featureCount].geometry.coordinates[0][LatLngCount][1] + ") meanLng(" +
                        lngMean + ") meanLat(" + latMean + ") trsLng(" + translateLng(json.features[featureCount].geometry.coordinates[0][LatLngCount][0], lngMean) + ") trnsLat(" +
                        translateLat(json.features[featureCount].geometry.coordinates[0][LatLngCount][1], latMean) + ")" );
                }
            }
        </script>
    </body>
</html>
